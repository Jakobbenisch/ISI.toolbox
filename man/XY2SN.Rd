% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SN_Transformation.R
\name{XY2SN}
\alias{XY2SN}
\title{A function for transforming XY to SN coordinates.}
\usage{
XY2SN(ThalwegCoordinates_HR, DepthCoordiantes_HRZ)
}
\arguments{
\item{ThalwegCoordinates_HR}{Dataframe with dim = n,2. First postion is the Hochwert (y-coordinate) and second ist the Rechtswert (x-coordinate). This dataset can be estimated by the centerline oy your river.}

\item{DepthCoordiantes_HRZ}{Dataframe with dim = n,2.  First postion is the Hochwert (y-coordinate), second ist the Rechtswert (x-coordinate) and third is the Depth (z-coordinate). This dataset contains the measured depth as well as the riverside coordinates with a corresponding depth of 0.}
}
\value{
A matrix containing the S-coordinates [,1], N-coordinates [,2] and the depth [,3].
}
\description{
The transformation needs 2 dataframes as input. One resembling the centerline, the other containing measured depth information and the riversides.\cr
The measured points must be within the riversides!
}
\examples{
### This example incoorporates an entire SN transformation ###
##In order to use the example you need to install and load the akima package as we need it for our grid interpolation##
# Create Testdata for this example
R=seq(362000,364000)
X=R-363000
H=X^2*10/80000+20*sin(X/50/pi)+5666100
H2=X^2*10/80000+20*sin(X/50/pi)-20+5666100
CL=0.5*(H2+H)

DPR=runif(n = 1500,min = 362010,max=363990)
DPH=c()
DPZ=c()
for(i in 1:length(DPR)){
  index=which.min(abs(R-DPR[i]))
  value=rnorm(1,mean=0,sd=5)+CL[index]
  d=abs(value-CL[index])
  depth=5+d*-5/10
  if(value>H[index]){value=H[index]-0.5}
  else if(value<H2[index]){value=H2[index]+0.5}
  d=abs(value-CL[index])
  depth=5+d*-5/10
  DPH=c(DPH,value)
  DPZ=c(DPZ,depth)
}

UB=data.frame(H=H,R=R,Z=rep(0,length(R)))
LB=data.frame(H=H2,R=R,Z=rep(0,length(R)))
Data=data.frame(H=DPH,R=DPR,Z=DPZ)
DP=rbind(UB[10:(dim(UB)[1]-10),],LB[10:(dim(LB)[1]-10),],Data)
CLP=data.frame(H=CL,R=R)

# plotting data before transformation and interpolation
XY=DP
R01=XY[,3]/max(XY[,3])
plot(XY[,2],XY[,1],col=rgb(1,1-R01,0))

# transform 2 SN
# CLP [H,R]; DP [H,R,Z]
SN_DP=XY2SN(CLP,DP)

# interpolate using interp of the akima package
mesh=interp(SN_DP[,1], SN_DP[,2], SN_DP[,3], duplicate = "strip", nx = 500, ny = 50)
# mesh list(S,N,Z)

# transform to Gauss Kruger
XY=SN2XY(CLP,mesh)
# XY matrix [,1]->H; [,2]->R; [,3]->Z

# getting rid of NA values that were produced by the interp function
XY=na.omit(XY)

# plotting result
R01=XY[,3]/max(XY[,3])
plot(XY[,2],XY[,1],col=rgb(1,1-R01,0))

# convert Matrix to Raster to have further plotting options
XYZ=Matrix.to.Raster(XY,h.res=50,r.res=500)
levelplot(t(XYZ[[3]]),col.regions = colorRampPalette(c("blue","yellow", "red")))
}
\seealso{
\link[ISI.Toolbox]{SN2XY}
}
