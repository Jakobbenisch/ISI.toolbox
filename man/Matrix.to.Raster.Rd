% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SN_Transformation.R
\name{Matrix.to.Raster}
\alias{Matrix.to.Raster}
\title{A function for transforming a matrix to a grid.}
\usage{
Matrix.to.Raster(MA, h.res = 250, r.res = 250)
}
\arguments{
\item{MA}{A matrix containing the H-coordinates (y) [,1], R-coordinates (x) [,2] and the depth (z) [,3].}

\item{h.res}{Integer secifying the resolution of the H coordinate.}

\item{r.res}{Integer secifying the resolution of the R coordinate.}
}
\value{
A grid (list).
}
\description{
Some plotting tools require a grid. This tool converts a Matrix to a grid (list).
}
\examples{
### This example incoorporates an entire SN transformation ###
##In order to use the example you need to install and load the akima package as we need it for our grid interpolation##
# Create Testdata for this example
R=seq(362000,364000)
X=R-363000
H=X^2*10/80000+20*sin(X/50/pi)+5666100
H2=X^2*10/80000+20*sin(X/50/pi)-20+5666100
CL=0.5*(H2+H)

DPR=runif(n = 1500,min = 362010,max=363990)
DPH=c()
DPZ=c()
for(i in 1:length(DPR)){
  index=which.min(abs(R-DPR[i]))
  value=rnorm(1,mean=0,sd=5)+CL[index]
  d=abs(value-CL[index])
  depth=5+d*-5/10
  if(value>H[index]){value=H[index]-0.5}
  else if(value<H2[index]){value=H2[index]+0.5}
  d=abs(value-CL[index])
  depth=5+d*-5/10
  DPH=c(DPH,value)
  DPZ=c(DPZ,depth)
}

UB=data.frame(H=H,R=R,Z=rep(0,length(R)))
LB=data.frame(H=H2,R=R,Z=rep(0,length(R)))
Data=data.frame(H=DPH,R=DPR,Z=DPZ)
DP=rbind(UB[10:(dim(UB)[1]-10),],LB[10:(dim(LB)[1]-10),],Data)
CLP=data.frame(H=CL,R=R)

# plotting data before transformation and interpolation
XY=DP
R01=XY[,3]/max(XY[,3])
plot(XY[,2],XY[,1],col=rgb(1,1-R01,0))

# transform 2 SN
# CLP [H,R]; DP [H,R,Z]
SN_DP=XY2SN(CLP,DP)

# interpolate using interp of the akima package
mesh=interp(SN_DP[,1], SN_DP[,2], SN_DP[,3], duplicate = "strip", nx = 500, ny = 50)
# mesh list(S,N,Z)

# transform to Gauss Kruger
XY=SN2XY(CLP,mesh)
# XY matrix [,1]->H; [,2]->R; [,3]->Z

# getting rid of NA values that were produced by the interp function
XY=na.omit(XY)

# plotting result
R01=XY[,3]/max(XY[,3])
plot(XY[,2],XY[,1],col=rgb(1,1-R01,0))

# convert Matrix to Raster to have further plotting options
XYZ=Matrix.to.Raster(XY,h.res=50,r.res=500)
levelplot(t(XYZ[[3]]),col.regions = colorRampPalette(c("blue","yellow", "red")))
}
